###### JVM 垃圾回收算法

复制算法 和 标记清理方法。

复制算法：两个区域 A 和 B，初始对象在 A，继续存活的对象被转移到 B。刺猬新生代最常用的算法；

标记清理：一块区域，标记可达对象，然后回收不可达对象，会出现碎片。引申出标记-整理算法；

标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象。

新生代和老年代：

新生代：初始对象，生命周期短的；

老年代（永久代）：长时间存在的对象

Serial New 收集器是针对新生代的收集器，采用复制算法；

Parallel New (并行)收集器，新生代采用复制算法，老年代采用标记整理；

Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法；

Serial Old（串行）收集器，新生代采用复制算法，老年代采用标记整理；

Parallel Old（并行）收集器，针对老年代，采用标记整理算法；

CMS 收集器：基于标记清理；

G1 收集器：整体上是基于标记整理，局部采用复制。

整个 Java 的垃圾回收是新生代和老年代的协作，叫做分代回收。

综上，新生代基本采用复制算法，老年代采用标记整理算法，cms 采用标记清理算法。

例：以下哪些 JVM 的垃圾回收方法采用的是复制算法回收？

A 新生代串行收集器

B 老年代串行收集器

C 并行收集器

D 新生代并行回收收集器

E 老年代并行回收收集器

F cms 收集器

答案：AD

###### 以下哪个方法用于定义线程的执行体？

A start()

B init()

C run()

D synchronized()

答案：C

run() 方法是线程执行体。start() 方法是开启多线程。

run() 相当于线程的任务处理逻辑的入口方法，它由 Java 虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。

而 start() 的作用是启动相应的线程。启动一个线程实际是请求 Java 虚拟机运行相应的线程，而这个线程何时能够运行时由线程调度器决定的。start() 调用结束并不表示相应线程已经开始运行，这个线程可能稍后运行，也可能永远不会运行。

###### 接口 / 抽象类 /实现类

两同两小一大原则：

函数名相同，参数类型相同；

子类返回类型小于等于父类方法返回类型，子类抛出异常小于等于父类方法抛出异常；

子类访问权限大于等于父类方法访问权限。

###### & 和 && 、｜ 和 ||

&、｜ 操作符用在整数上是按位与、或，用在布尔类型变量上和 &&、||  基本一样；& 和 ｜ 不具备短路功能，&&  和 || 具备短路功能。

Consider the following code:

Stirng s = null;

Which code fragments cause an object of type NullPointerException to be thrown?

A if((s!=null) & (s.length() > 0))

B if((s!=null) && (s.length() > 0))

C if((s==null) | (s.length() == 0))

D if((s==null) || (s.length() == 0))

答案：AC

s = null，因此只要执行了 s.length() 就会抛出异常。A 、C都会执行。BD由于短路，都不会执行。

